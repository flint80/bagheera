# Обработка RSS-ленты #

![http://bagheera.googlecode.com/svn/trunk/help/using_program/figures/rss_logic.png](http://bagheera.googlecode.com/svn/trunk/help/using_program/figures/rss_logic.png)

> В этом разделе описана логика обработки RSS-ленты, шаблон которой задается декоратором `RssDecorator.groovy`. Более детальную информацию по методам декоратора можно посмотреть в разделе [RssDecorator](RssDecorator.md) , либо анализируя код `RssDecorator.groovy`. Обработка RSS-ленты состоит из следующих этапов:

  1. **Инициализация.** Декоратор инициализируется двумя простыми параметрами: адрес RSS-ленты и адрес логотипа, который используется как обложка книги. Второй параметр является опциональным.
  1. **Определение начала периода.** Это момент времени, начиная с которого новости попадают в FB2-книгу. Тут есть две стратегии:
    1. Использование временной метки. В этом случае включаются новости с момента последнего создания книги из этой ленты и до текущего момента.
    1. Получение данных за определеный срок. Например, получить данные за 2 недели и до текущего момента. В первом случае нужно использовать функцию useTimeStamp(boolean askForTimeStampValue,boolean confirmTimeStampValue)  . Первый аргумент определяет, нужно ли уточнять у пользователя дату начала периода. Если флаг выставлен в true , то перед началом создания книги выводится окно с возможностью редактирования даты начала. Второй аргумент, определяет нужно ли запрашивать у пользователя подтверждение оь обновлении временной ветки. Оба аргумента опциональны. При их отсутсвии считается, что оба они равны false .Во втором случае нужно использовать функцию usePeriod(boolean askForPeriodValue, int defaultRetrievePeriod)  . Первый аргумент определяет, нужно ли уточнять у пользователя период, или использовать последнее введенное значение автоматически. Если флаг выставлен в true , то перед началом создания книги выводится окно с возможностью редактирования продолжительности периода. Второй аргумент, продолительность периода по-умолчанию (т.е если первый аргумент равен false). Оба аргумента опциональны. При их отсутсвии считается, что askForPeriodValue = false , а defaultRetrievePeriod = 14 . При отсутствии этих функций используется поведение по-умолчанию: useTimeStamp(false, false) .
  1. Получение контента RSS-ленты. Загружается контент, расположенный по указанному при инициализации URL.
  1. Объединение с архивными данными. Если скрипт запускается не в первый раз, то от обработанный в предыдущий раз контент, сохраняется на диск. Нужно это вот для чего. Многие источники RSS-лент хранят новости лишь за последние пару дней, а, зачастую, хочется получить книжку за, например, последнюю неделю. Если скрипт запускается регулярно, то на диске сохраняется контент за необходимый период, и при очередном запуске скрипта сохраненные новости подмешиваются к новым. Результирующий список фильтруется согласно определенному на предыдущих шагах началу периода.
  1. Пост-обработка свежих новостей. Если RSS-лента содержит не полную новость, а лишь ее анонс, то необходимо заменить анонс полной версией статьи. Это надо делать в методе updateItem , который в качестве аргумента получает HTMLSection . Мы рассмотрим пример применения этого метода ниже при описании скрипта обработки ленты Компьютерры.
  1. Обновление архивных данных. Как уже упоминалось на шаге 4, после получения очередной порции RSS-новостей, обновляется локальный кеш новостей.
  1. Обновление архивных данных. Как уже упоминалось на шаге 4, после получения очередной порции RSS-новостей, обновляется локальный кеш новостей.
  1. Создание FB2. На этом шаге генерируется контент FB2-книги.
  1. Сохранение книги в файл. На этом шаге контент сохраняется в файл на локальном диске в директории output . При автоматической генерации имя файла составляется из названия RSS-ленты и периода, за который запрошены новости. Вы можете изменить алгоритм генерации имени файла, используя метод buildFileName , в который в качестве аргумента передается Контекст выполнения скрипта.
  1. Обновление временной метки. Если конфигурируете скрипт функцией useTimeStamp с параметром confirmTimeStampValue = true (см шаг 2), то перед обновлением временной метки у пользователя запрашивается подтверждение.

> Рассмотрим в качетсве примера скрипт обработки RSS-ленты Компютерры:

```

//@ description Computerra
showMessage 'готовим книжку - ждите...'
rss('http://feeds.feedburner.com/ct_news?format=xml', 'http://www.computerra.ru/new/logo2.gif'){
	useTimeStamp(true,false)
	updateItem{
		String content = loadAsString it.relatedURL
		if(content){
			String subContent = content.findFirst('<div id="content">(.*)<div id="fin">', '<!-- start -->(.*)<!-- fin -->', '<div id="content">(.*)')
			if(subContent){
				content = subContent
			} else{
				log "subcontent is null, content = $content"
				it.htmlContent = ' '
				return
			}
			content = content.deleteAll('<form.+?/form>','<noscript.+?/noscript>', '<iframe.+?/>')
			it.htmlContent = content
			log 'modified content of ' + it.relatedURL + ' is ' + content
		}
	}
}
showMessage 'генерация книжки завершена'

```

Первая строка задает описание скрипта (то как он будет отображен в списке доступных скриптов).

Вторая строка выводит на интерфейс сообщение "готовим книжку - ждите...". Функция showMessage - это результат работы декоратора `CommunicationsDecorator.groovy`. Полный список функций, добавляемых этим декоратором описан в [CommunicationsDecorator](CommunicationsDecorator.md).

Третья строка запускает генератор FB2-книги из RSS-ленты. Генератор инициализируется адресом RSS-ленты ( http://feeds.feedburner.com/ct_news?format=xml ) и адресом логотипа `http://www.computerra.ru/new/logo2.gif`

Четвертая строка конфигурирует генератор так, чтобы он использовал временную ветку. При этом, вначале будет выводится диалоговое окно с подтверждением даты начала периода.

Строки 5-20 определяют алгоритм постобработки сообщений. Копмпьютерра предоставляет лишь анонс новости, а нам нужна полная версия статьи.

В строке 6 загружается контент статьи, при этом используется функция loadAsString , которая создается декоратором [CommunicationsDecorator](CommunicationsDecorator.md)

> В строках

```

content = content.findFirst('<div id="content">(.*)<div id="fin">', '<!-- start -->(.*)<!-- fin -->', '<div id="content">(.*)')
content = content.deleteAll('<form.+?/form>','<noscript.+?/noscript>', '<iframe.+?/>')

```

> из текста статьи вычленяется содержательная часть(которая находится либо внутри тега <div> , либо внутри блока от <!-- start --> до <iframe.+?/> ), а затем из контента удаляются лишние куски с кодом JavaScript и IFrame.</li></ul>

Функции findFirst и deleteAll появляются в результате работы декоратора StringUtilsDecorator.groovy (см <a href='StringUtilsDecorator.md'>StringUtilsDecorator</a>). Функции работы со строками активно используют регулярные выражения Java (см <a href='http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html'>или http://docs.oracle.com/javase/tutorial/essential/regex/intro.html</a>).<br>
<br>
<blockquote>В строке

```

it.htmlContent = content

```

> обновляется контент новости.  И, наконец, в строке

```

log 'modified content of ' + it.relatedURL + ' is ' + content

```

> для целей отладки обноленный контент логируется в файл log/script.log . Функция log добавлена декоратором [LoggerDecorator](LoggerDecorator.md).

Ну вот и все. Теперь Вы научились обрабатывать любые RSS-ленты, в том числе, и с анонсами статей. Для справок пользуйте информацию из Приложений.